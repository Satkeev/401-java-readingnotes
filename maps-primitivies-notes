###Java Type System
Java has a two-fold type system consisting of primitives such as int, boolean and reference types such
as Integer, Boolean. Every primitive type corresponds to a reference type.
Every object contains a single value of the corresponding primitive type. The wrapper classes are immutable
(so that their state can't change once the object is constructed) and are final (so that we can't inherit from them).
Under the hood, Java performs a conversion between the primitive and reference types if an actual type is
different from the declared one:

Integer j = 1;          // autoboxing
int i = new Integer(1); // unboxing
The process of converting a primitive type to a reference one is called autoboxing, the opposite process is called unboxing.

### Pros and Cons
The decision what object is to be used is based on what application performance we try to achieve, how much available
memory we have, the amount of available memory and what default values we should handle.
If we face none of those, we may ignore these considerations though it's worth knowing them.

##Single Item Memory Footprint
Just for the reference, the primitive type variables have the following impact on the memory:

boolean – 1 bit
byte – 8 bits
short, char – 16 bits
int, float – 32 bits
long, double – 64 bits
In practice, these values can vary depending on the Virtual Machine implementation. In Oracle's VM, the 
boolean type, for example, is mapped to int values 0 and 1, so it takes 32 bits, as described here: 
Primitive Types and Values.
Variables of these types live in the stack and hence are accessed fast. For the details, we recommend
our tutorial on the Java memory model.
The reference types are objects, they live on the heap and are relatively slow to access. They have a 
certain overhead concerning their primitive counterparts.
The concrete values of the overhead are in general JVM-specific. Here, we present results for a 64-bit 
virtual machine with these parameters:

java 10.0.1 2018-04-17
Java(TM) SE Runtime Environment 18.3 (build 10.0.1+10)
Java HotSpot(TM) 64-Bit Server VM 18.3 (build 10.0.1+10, mixed mode)
To get an object's internal structure, we may use the Java Object Layout tool (see our another
tutorial on how to get the size of an object).
It turns out that a single instance of a reference type on this JVM occupies 128 bits except for Long 
and Double which occupy 192 bits:

Boolean – 128 bits
Byte – 128 bits
Short, Character – 128 bits
Integer, Float – 128 bits
Long, Double – 192 bits
We can see that a single variable of Boolean type occupies as much space as 128 primitive ones, while one Integer
variable occupies as much space as four int ones.

##Memory Footprint for Arrays
The situation becomes more interesting if we compare how much memory occupy arrays of the types under consideration.
When we create arrays with the various number of elements for every type, we obtain a plot:
that demonstrates that the types are grouped into four families with respect to how the memory m(s) depends
on the number of elements s of the array:

long, double: m(s) = 128 + 64 s
short, char: m(s) = 128 + 64 [s/4]
byte, boolean: m(s) = 128 + 64 [s/8]
the rest: m(s) = 128 + 64 [s/2]
where the square brackets denote the standard ceiling function.
Surprisingly, arrays of the primitive types long and double consume more memory than their wrapper classes Long and Double.
We can see either that single-element arrays of primitive types are almost always more expensive (except for long and double)
than the corresponding reference type.
##Performance
The performance of a Java code is quite a subtle issue, it depends very much on the hardware on which the code runs, 
on the compiler that might perform certain optimizations, on the state of the virtual machine, on the activity
of other processes in the operating system.
As we have already mentioned, the primitive types live in the stack while the reference types live in the heap.
This is a dominant factor that determines how fast the objects get be accessed.

###What Is an Exception?
The term exception is shorthand for the phrase "exceptional event."
Definition: An exception is an event, which occurs during the execution of a program, that disrupts the normal
flow of the program's instructions.
When an error occurs within a method, the method creates an object and hands it off to the runtime system.
The object, called an exception object, contains information about the error, including its type and the state 
of the program when the error occurred. Creating an exception object and handing it to the runtime system is called throwing an exception.
After a method throws an exception, the runtime system attempts to find something to handle it. The set of possible
"somethings" to handle the exception is the ordered list of methods that had been called to get to the method where
the error occurred. The list of methods is known as the call stack (see the next figure).

The call stack showing three method calls, where the first method called has the exception handler.
The call stack.

The runtime system searches the call stack for a method that contains a block of code that can handle the exception.
This block of code is called an exception handler. The search begins with the method in which the error occurred and
proceeds through the call stack in the reverse order in which the methods were called. When an appropriate handler 
is found, the runtime system passes the exception to the handler. An exception handler is considered appropriate 
if the type of the exception object thrown matches the type that can be handled by the handler.

The exception handler chosen is said to catch the exception. If the runtime system exhaustively searches all
the methods on the call stack without finding an appropriate exception handler, as shown in the next figure,
the runtime system (and, consequently, the program) terminates.

The call stack showing three method calls, where the first method called has the exception handler.
Searching the call stack for the exception handler.
